# Add these methods to the Library class in lib.py

def removeBook(self, title):
    """Remove a book from the library"""
    try:
        check_query = "SELECT * FROM books WHERE title = %s"
        self.db.cursor.execute(check_query, (title,))
        book = self.db.cursor.fetchone()
        
        if not book:
            return False, "Book not found"
            
        # Check if any copies are borrowed
        check_borrowed = "SELECT COUNT(*) FROM borrowed_books WHERE book_title = %s AND returned = FALSE"
        self.db.cursor.execute(check_borrowed, (title,))
        borrowed_count = self.db.cursor.fetchone()[0]
        
        if borrowed_count > 0:
            return False, "Cannot remove book - some copies are currently borrowed"
        
        # Delete the book
        delete_query = "DELETE FROM books WHERE title = %s"
        self.db.cursor.execute(delete_query, (title,))
        self.db.connection.commit()
        return True, "Book successfully removed"
        
    except Error as e:
        return False, f"Failed to remove book: {str(e)}"

def editBook(self, old_title, new_title, new_author, new_category, new_total_copies):
    """Edit book details"""
    try:
        # Check if book exists
        check_query = "SELECT available_copies, total_copies FROM books WHERE title = %s"
        self.db.cursor.execute(check_query, (old_title,))
        book = self.db.cursor.fetchone()
        
        if not book:
            return False, "Book not found"
        
        available_copies, total_copies = book
        borrowed_copies = total_copies - available_copies
        
        if new_total_copies < borrowed_copies:
            return False, f"Cannot reduce total copies below borrowed copies ({borrowed_copies})"
        
        # Calculate new available copies
        new_available_copies = new_total_copies - borrowed_copies
        
        # Update the book details
        update_query = """
            UPDATE books 
            SET title = %s, author = %s, category = %s, 
                total_copies = %s, available_copies = %s 
            WHERE title = %s
        """
        self.db.cursor.execute(update_query, 
            (new_title, new_author, new_category, 
             new_total_copies, new_available_copies, old_title))
        
        # Update borrowed_books table if title changed
        if old_title != new_title:
            update_borrowed = "UPDATE borrowed_books SET book_title = %s WHERE book_title = %s"
            self.db.cursor.execute(update_borrowed, (new_title, old_title))
        
        self.db.connection.commit()
        return True, "Book details updated successfully"
        
    except Error as e:
        return False, f"Failed to update book details: {str(e)}"

# Add these methods to the LibraryGUI class in gui.py

def edit_book(self):
    # Get selected book
    selected = self.books_tree.selection()
    if not selected:
        messagebox.showwarning("Warning", "Please select a book to edit")
        return
    
    # Get book details
    book_values = self.books_tree.item(selected[0])['values']
    if not book_values:
        return
    
    # Create dialog for editing
    dialog = tk.Toplevel(self.root)
    dialog.title("Edit Book")
    dialog.geometry("400x350")
    dialog.resizable(False, False)
    
    # Make dialog modal
    dialog.transient(self.root)
    dialog.grab_set()
    
    # Create main frame with padding
    main_frame = ttk.Frame(dialog, padding="20 10 20 10")
    main_frame.pack(fill=tk.BOTH, expand=True)
    
    # Title
    ttk.Label(main_frame, text="ðŸ“š Edit Book Details", 
             font=('Helvetica', 12, 'bold')).pack(pady=(0,20))
    
    # Input fields frame
    fields_frame = ttk.Frame(main_frame)
    fields_frame.pack(fill=tk.X, pady=5)
    
    # Book details
    details = {
        'Title': book_values[0],
        'Author': book_values[1],
        'Category': book_values[2],
        'Total Copies': book_values[4]
    }
    
    variables = {}
    for label, value in details.items():
        frame = ttk.Frame(fields_frame)
        frame.pack(fill=tk.X, pady=5)
        ttk.Label(frame, text=f"{label}:*", width=15).pack(side=tk.LEFT)
        var = tk.StringVar(value=value)
        variables[label] = var
        ttk.Entry(frame, textvariable=var, width=30).pack(side=tk.LEFT)
    
    def submit():
        try:
            # Validate input
            new_title = variables['Title'].get().strip()
            new_author = variables['Author'].get().strip()
            new_category = variables['Category'].get().strip()
            try:
                new_total = int(variables['Total Copies'].get())
                if new_total < 1:
                    raise ValueError
            except ValueError:
                messagebox.showerror("Error", "Total copies must be a positive number")
                return
            
            if not all([new_title, new_author, new_category]):
                messagebox.showerror("Error", "All fields are required")
                return
            
            # Update book
            success, message = self.library.editBook(
                book_values[0], new_title, new_author, 
                new_category, new_total
            )
            
            if success:
                messagebox.showinfo("Success", message)
                dialog.destroy()
                self.show_all_books()  # Refresh book list
            else:
                messagebox.showerror("Error", message)
            
        except Exception as e:
            messagebox.showerror("Error", f"Failed to update book: {str(e)}")
    
    # Buttons
    buttons_frame = ttk.Frame(main_frame)
    buttons_frame.pack(fill=tk.X, pady=20)
    ttk.Button(buttons_frame, text="Update", command=submit).pack(side=tk.LEFT, padx=5)
    ttk.Button(buttons_frame, text="Cancel", command=dialog.destroy).pack(side=tk.LEFT, padx=5)

def remove_book(self):
    # Get selected book
    selected = self.books_tree.selection()
    if not selected:
        messagebox.showwarning("Warning", "Please select a book to remove")
        return
    
    # Get book details
    book_values = self.books_tree.item(selected[0])['values']
    if not book_values:
        return
    
    # Confirm deletion
    if not messagebox.askyesno("Confirm Remove", 
        f"Are you sure you want to remove '{book_values[0]}' from the library?"):
        return
    
    try:
        success, message = self.library.removeBook(book_values[0])
        if success:
            messagebox.showinfo("Success", message)
            self.show_all_books()  # Refresh book list
        else:
            messagebox.showerror("Error", message)
    except Exception as e:
        messagebox.showerror("Error", f"Failed to remove book: {str(e)}")